/*
 *  SPDX-FileCopyrightText: 2023 Peter Hasse <peter.hasse@fokus.fraunhofer.de>
 *  SPDX-FileCopyrightText: 2023 Johann Hackler <johann.hackler@fokus.fraunhofer.de>
 *  SPDX-FileCopyrightText: 2023 Fraunhofer FOKUS
 *
 *  SPDX-License-Identifier: BSD-3-Clause-Clear
 */

package de.fraunhofer.fokus.OpenMobileNetworkToolkit;

import android.content.ClipData;
import android.content.ClipboardManager;
import android.content.Context;
import android.os.Bundle;
import android.os.PersistableBundle;
import android.telephony.TelephonyManager;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TableLayout;
import android.widget.TableRow;
import android.widget.TextView;
import android.widget.Toast;

import androidx.activity.OnBackPressedCallback;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.cardview.widget.CardView;
import androidx.fragment.app.Fragment;
import androidx.navigation.NavController;
import androidx.navigation.fragment.NavHostFragment;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

public class CarrierSettingsFragment extends Fragment {
    final String TAG = "CarrierSettingsFragment";
    Context context;
    TelephonyManager tm;

    public CarrierSettingsFragment() {
        super(R.layout.fragment_carrier_settings);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        NavController navController = NavHostFragment.findNavController(this);
        OnBackPressedCallback callback = new OnBackPressedCallback(true /* enabled by default */) {
            @Override
            public void handleOnBackPressed() {
                navController.navigate(R.id.HomeFragment);
            }
        };
        requireActivity().getOnBackPressedDispatcher().addCallback(this, callback);

    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        return inflater.inflate(R.layout.fragment_carrier_settings, container, false);
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        GlobalVars gv = GlobalVars.getInstance();
        tm = gv.getTm();
        context = requireContext();
        super.onViewCreated(view, savedInstanceState);

        Button btn_read = requireView().findViewById(R.id.button_read_carrier_settings);
        btn_read.setOnClickListener(view1 -> read_settings());

        Button btn_copy_csv = requireView().findViewById(R.id.button_copy_csv_carrier_settings);
        btn_copy_csv.setOnClickListener(view1 -> copy_settings_as_csv());

        CardView cv = requireView().findViewById(R.id.carrier_settings_card_view);
        cv.setRadius(15);
        cv.setContentPadding(20, 10, 10, 0);
        cv.setUseCompatPadding(true);
        TextView tv = new TextView(context);
        tv.setText(R.string.press_the_read_button);
        cv.addView(tv);
    }

    /**
    * Convert a persistent bundle to a string map. It seems there is no nice way to this.
    * Nested bundles will be flattened to string
     * @noinspection ResultOfMethodCallIgnored
     */
    private Map<String, String> bundle_to_map(PersistableBundle bundle) {
        Map<String, String> map = new HashMap<>();
        for (String key : bundle.keySet()) {
            Object obj = bundle.get(key);
            String ret = "";
            if (obj instanceof int[]) {
                ret = Arrays.toString((int[]) obj);
            } else if (obj instanceof long[]) {
                ret = Arrays.toString((long[]) obj);
            } else if (obj instanceof double[]) {
                ret = Arrays.toString((double[]) obj);
            } else if (obj instanceof boolean[]) {
                ret = Arrays.toString((boolean[]) obj);
            } else if (obj instanceof String[]) {
                ret = Arrays.toString((String[]) obj);
            } else if (obj instanceof Integer || obj instanceof Long || obj instanceof Double) {
                ret = String.valueOf(obj);
            } else if (obj instanceof String) {
                ret = obj.toString();
            } else if (obj instanceof Boolean) {
                ret = obj.toString();
            } else if (obj instanceof PersistableBundle) {
                Map<String, String> bundle_map  = bundle_to_map((PersistableBundle) obj);
                ret = bundle_map.toString();
            } else {
                try {
                    obj.toString();
                } catch (Exception e) {
                    Log.d(TAG, "Not printable unknown obj received");
                }
            }
            map.put(key.toUpperCase(), ret);
        }
        return map;
    }

    private void read_settings() {
        CardView cv = requireView().findViewById(R.id.carrier_settings_card_view);
        cv.removeAllViews();
        TableLayout tl = new TableLayout(context);
        tl.setColumnShrinkable(1, true);
        PersistableBundle cf =  tm.getCarrierConfig();
        Log.d(TAG, cf.toString());
        Map<String, String> map = bundle_to_map(cf);
        EditText filter = requireView().findViewById(R.id.carrier_settings_filter);
        String filter_string = filter.getText().toString().toUpperCase();
        for (Map.Entry<String, String> entry : map.entrySet()) {
            if (filter_string.isEmpty()) {
                TableRow tr = getTableRow(entry);
                tl.addView(tr);
            } else if (entry.getKey().contains(filter_string)) {
                TableRow tr = getTableRow(entry);
                tl.addView(tr);
            }
        }
        cv.addView(tl);
    }

    @NonNull
    private TableRow getTableRow(Map.Entry<String, String> entry) {
        TextView key_column = new TextView(context);
        TextView value_column = new TextView(context);
        TableRow tr = new TableRow(context);
        key_column.setText(entry.getKey().toUpperCase());
        key_column.setWidth(600);
        key_column.setTextIsSelectable(true);
        key_column.setPadding(0, 0, 0, 20);
        value_column.setText(entry.getValue());
        value_column.setPadding(50, 0, 0, 0);
        value_column.setTextIsSelectable(true);
        tr.addView(key_column);
        tr.addView(value_column);
        return tr;
    }

    private void copy_settings_as_csv() {
        PersistableBundle cf = tm.getCarrierConfig();
        if (cf == null) {
            Toast.makeText(context, "No carrier config available", Toast.LENGTH_SHORT).show();
            return;
        }

        Map<String, String> map = bundle_to_map(cf);
        StringBuilder csv = new StringBuilder();

        // Add CSV header
        csv.append("Key,Value\n");

        // Add each entry as a CSV row
        for (Map.Entry<String, String> entry : map.entrySet()) {
            csv.append(escapeCSV(entry.getKey()));
            csv.append(",");
            csv.append(escapeCSV(entry.getValue()));
            csv.append("\n");
        }

        // Copy to clipboard
        ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);
        ClipData clip = ClipData.newPlainText("Carrier Settings CSV", csv.toString());
        clipboard.setPrimaryClip(clip);

        Toast.makeText(context, "Copied " + map.size() + " settings to clipboard as CSV", Toast.LENGTH_SHORT).show();
        Log.d(TAG, "Copied carrier settings to clipboard as CSV: " + map.size() + " entries");
    }

    private String escapeCSV(String value) {
        if (value == null) {
            return "";
        }
        // If the value contains comma, newline, or quote, wrap it in quotes and escape internal quotes
        if (value.contains(",") || value.contains("\n") || value.contains("\"")) {
            return "\"" + value.replace("\"", "\"\"") + "\"";
        }
        return value;
    }
}
